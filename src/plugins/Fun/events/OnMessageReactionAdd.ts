import { onceOptionMsg, oneOptionMsg } from "../Fun.plugin";
import {
	BaseEvent,
	BaseMessage,
	BasePlugin,
	Discord,
	DiscordMessage,
	EmbedHelper,
	FriendlyError,
	Logger,
} from "@framedjs/core";
import { oneLine } from "common-tags";
import Emoji from "node-emoji";
import Poll from "../commands/Poll";
import nanoid from "nanoid";

interface ReactionData {
	// Generated by nanoid
	randomId: string;

	// Emotes being removed currently
	reactionEmojiNames: string[];
}

export default class extends BaseEvent {
	// user ID and message ID (separated by comma),
	userReactions = new Map<string, ReactionData>();

	constructor(plugin: BasePlugin) {
		super(plugin, {
			id: "pollMessageReactionAdd",
			discord: {
				name: "messageReactionAdd",
			},
		});
	}

	async run(
		reaction: Discord.MessageReaction,
		user: Discord.User | Discord.PartialUser
	): Promise<void> {
		Logger.silly(`Reaction Add From: ${user.id}`);

		if (user.bot) return;

		let reactionMessage: Discord.Message;

		// https://discordjs.guide/popular-topics/reactions.html#listening-for-reactions-on-old-messages
		// When we receive a reaction we check if the reaction is partial or not
		if (reaction.partial) {
			// If the message this reaction belongs to was removed the fetching
			// might result in an API error, which we need to handle
			try {
				Logger.debug(`Fetching reaction... ${reaction.message.id}`);
				await reaction.fetch();
			} catch (error) {
				Logger.error(
					"OnMessageReactionAdd.ts: Something went wrong when fetching the reaction:"
				);
				Logger.error((error as Error).stack);
				return;
			}
		}

		// Fetches the message too
		if (reaction.message.partial) {
			try {
				Logger.debug(`Fetching message... ${reaction.message.id}`);
				reactionMessage = await reaction.message.fetch();
			} catch (error) {
				Logger.error(
					"OnMessageReactionAdd.ts: Something went wrong when fetching the message:"
				);
				Logger.error((error as Error).stack);
				return;
			}
		} else {
			reactionMessage = reaction.message;
		}

		// If these are null, it's probably safe to skip
		// if (reaction.message == null || reaction.message.content == null)
		// 	return;

		const embedDescription =
			reaction.message.embeds[0]?.description?.toLocaleLowerCase();
		const isPollEmbed = embedDescription?.includes("poll by <@");

		// Finds the place
		const place = reaction.message.guild
			? await BaseMessage.discordGetPlace(
					this.client,
					reaction.message.guild
			  )
			: this.client.provider.places.get("discord_default");
		if (!place) {
			Logger.error("Couldn't find place");
			return;
		}

		const commandRan = await this.client.formatting.format(
			`$(command poll)`,
			place
		);
		const newContent = `${
			reaction.message.content ??
			""
				.replace(
					"poll:",
					await this.client.formatting.format(commandRan, place)
				)
				.trim()
		}`;

		const newMsg = new DiscordMessage({
			client: this.client,
			content: newContent,
			discord: {
				client: reaction.message.client,
				id: reaction.message.id,
				channel: reaction.message.channel,
				author: reaction.message.author ?? undefined,
				guild: reaction.message.guild,
			},
		});
		await newMsg.getMessageElements(place);
		const parsedResults = await Poll.customParse(newMsg, true);

		const singleVoteOnly =
			embedDescription?.endsWith(oneOptionMsg.toLocaleLowerCase()) ||
			embedDescription?.endsWith(onceOptionMsg.toLocaleLowerCase()) ||
			parsedResults?.pollOptions.includes("once") ||
			parsedResults?.pollOptions.includes("one") ||
			parsedResults?.pollOptions.includes("single");

		const isPollCommand =
			reactionMessage.content.startsWith(commandRan) ||
			reactionMessage.content.startsWith("poll:") ||
			isPollEmbed;

		if (isPollCommand && singleVoteOnly) {
			// Gets cached users from reactions
			const fetches = [];
			for (const extraReaction of reaction.message.reactions.cache) {
				const reaction = extraReaction[1];
				if (reaction.users.cache.size != reaction.count) {
					Logger.silly("User count discrepancy found:");
					Logger.silly(
						`  reaction.users.cache.size: ${reaction.users.cache.size}`
					);
					Logger.silly(`  reaction.count: ${reaction.count}`);
					fetches.push(reaction.users.fetch({}));
				}
			}
			try {
				await Promise.all(fetches);
			} catch (error) {
				Logger.error((error as Error).stack);
			}

			// https://discordjs.guide/popular-topics/reactions.html#removing-reactions-by-user
			const extraUserReactions = reaction.message.reactions.cache.filter(
				extraReaction => {
					const userHasReaction = extraReaction.users.cache.has(
						user.id
					);
					const isSimplePollReaction = isPollEmbed != true;

					// v13 change, if there's no name attached to the emoji, just give up??
					if (extraReaction.emoji.name == null) return false;

					// Generous/lazy check that tries to get all valid options from the embed
					// TODO: add checks for the emotes at the very beginning of a new line
					const isOptionPollReaction =
						embedDescription?.includes(extraReaction.emoji.name) ==
							true && isPollEmbed == true;
					const extraReactionJustPlaced =
						extraReaction.emoji.name == reaction.emoji.name;

					return (
						userHasReaction &&
						(isSimplePollReaction || isOptionPollReaction) &&
						!extraReactionJustPlaced
					);
				}
			);

			// IDs
			const randomId = nanoid.nanoid();
			const uID = `${user.id},${reaction.message.id}`;

			// For debug
			const truncRandomId = `${randomId.substr(0, 5)}..`;
			const truncUID = `${user.id.substr(0, 5)}..,${(
				reaction.message.id as string
			).substr(0, 5)}..`;

			try {
				if (!(reaction.message.channel instanceof Discord.DMChannel)) {
					const botMember = reaction.message.guild?.me ?? null;

					// Debug info
					if (Logger.isDebugEnabled()) {
						let debugReactionsList = "";
						for await (const reaction of extraUserReactions.values()) {
							debugReactionsList += oneLine`
							${reaction.emoji.name}
							(${Emoji.unemojify(reaction.emoji.name ?? `(null emoji)`)}) `;
						}
						Logger.debug(
							oneLine`${truncUID} | ${truncRandomId} | Extra reactions: ${debugReactionsList}`
						);
					}

					for await (const reaction of extraUserReactions.values()) {
						// Permission check
						if (
							!(
								botMember &&
								botMember.permissions.has(["MANAGE_MESSAGES"])
							)
						) {
							throw new FriendlyError(
								"The bot doesn't have the `MANAGE_MESSAGES` permission!",
								"Bot Missing Permissions"
							);
						}

						const userReactionData = this.userReactions.get(uID);
						let reactionEmojiNames = userReactionData
							? userReactionData.reactionEmojiNames
							: [];

						Logger.debug(
							`${truncUID} | ${truncRandomId} | reactionEmojiNames: ${reactionEmojiNames}`
						);

						// v13 change, if there's no name attached to the emoji, just give up??
						if (reaction.emoji.name == null) return;

						// If the emoji being removed in this list is already being removed, skip it
						if (reactionEmojiNames.includes(reaction.emoji.name)) {
							Logger.info(oneLine`${truncUID} | ${truncRandomId} | ${
								reaction.emoji.name
							}
							(${Emoji.unemojify(reaction.emoji.name)}) already being removed, skipping...`);
							continue;
						} else {
							// Adds the emoji to the list
							reactionEmojiNames.push(reaction.emoji.name);
							this.userReactions.set(uID, {
								randomId,
								reactionEmojiNames,
							});
						}

						// Removes a user's reaction
						if (reaction.users.cache.has(user.id)) {
							Logger.debug(oneLine`
							${truncUID} | ${truncRandomId} | REMOVING ${reaction.emoji.name}
							(${Emoji.unemojify(reaction.emoji.name)})
							from ${reaction.message.id} by ${user.tag}`);

							await reaction.users.remove(user.id);

							Logger.debug(oneLine`${truncUID} | ${truncRandomId} | REMOVED 
							${reaction.emoji.name} (${Emoji.unemojify(reaction.emoji.name)})`);
						} else {
							Logger.debug(oneLine`${truncUID} | ${truncRandomId} | SKIPPED
							${reaction.emoji.name}
							(${Emoji.unemojify(reaction.emoji.name)})
							from ${reaction.message.id} by ${user.tag}`);
						}

						// Removes the emoji from the list
						reactionEmojiNames = reactionEmojiNames.filter(
							item => item != reaction.emoji.name
						);
						this.userReactions.set(uID, {
							randomId,
							reactionEmojiNames,
						});
					}
				} else {
					await newMsg.send(
						"The `single` option isn't supported in DMs!"
					);
				}
			} catch (error) {
				if (error instanceof FriendlyError) {
					const embed = EmbedHelper.getTemplate(
						reactionMessage,
						await EmbedHelper.getCheckOutFooter(
							this.client.formatting,
							place,
							this.client.footer
						)
					)
						.setTitle(error.friendlyName)
						.setDescription(error.message);
					await reaction.message.channel.send({ embeds: [embed] });
				} else if (error instanceof Error) {
					Logger.error((error as Error).stack);
				} else if (typeof error == "string") {
					Logger.debug(error);
				}
				return;
			}

			this.userReactions.delete(uID);
			Logger.info(
				`${truncUID} | ${truncRandomId} | DONE processing single poll command!`
			);
		}
	}
}
